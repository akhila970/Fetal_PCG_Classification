# -*- coding: utf-8 -*-
"""CSV_CONV

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sDxsmCw0NIlwlrmgfz-Uvkm5UZJrifCi
"""

import pandas as pd
from datetime import datetime
import time
import numpy as np
import keras
from keras.models import Sequential
from keras.layers import LSTM,Input,Dropout,Dense,RepeatVector,TimeDistributed
from matplotlib import pyplot as plt
from sklearn.preprocessing import StandardScaler
from keras.models import Model
import seaborn as sns

file = "Test_1.csv"
d = pd.read_csv(file)
d['Elapsed time'] = d['Elapsed time'].str.replace("'","", regex=True)
print(d)

d.to_csv(file,index=False)

d['Elapsed time'] = pd.to_datetime(d['Elapsed time'])
d.set_index('Elapsed time', inplace=True)

d_resampled = d.resample("10S").agg({"PCG": "mean"})
d_resampled.reset_index(inplace=True)

print(d_resampled)

mean_pcg = d_resampled['PCG'].mean()
d_resampled['PCG'].fillna(mean_pcg, inplace=True)

# #has_nan = df_resampled.isna().any()
# #print(has_nan)
# print(df_resampled)

d_resampled.to_csv('TEST_1.csv')


t1 = pd.read_csv('TEST_1.csv')
dfrt = t1.loc[:, ['Elapsed time', 'PCG']].copy()
print(dfrt)

df = pd.read_csv("GW_36_1.csv")
df['Elapsed time'] = df['Elapsed time'].str.replace("'","", regex=True)
print(df)
df.to_csv("GW_36_1.csv",index=False)

# df = pd.read_csv("GW_36_1.csv")
# df['Elapsed time']=df['Elapsed time'].apply(pd.to_datetime, format='%M:%S.%f')
# #df['Elapsed time']=pd.to_datetime(df['Elapsed time'])
# #df.to_csv("GW_36_1.csv",index=False)
# df.head()
# df.shape



df['Elapsed time'] = pd.to_datetime(df['Elapsed time'])

# Set 'Elapsed time' as the index
df.set_index('Elapsed time', inplace=True)

# Resample and aggregate with different functions for each column
df_resampled = df.resample("10S").agg({"PCG": "mean"})

# Reset the index to have 'Elapsed time' as a separate column again
#df_resampled.reset_index(inplace=True)
df_resampled.reset_index(inplace=True)
print(df_resampled)

# Now df_resampled will have two columns: 'Elapsed time' and 'PCG', with the resampled 'Elapsed time' and the mean of 'PCG' values for each 10-second interval.


# has_nan = df_resampled.isna().any()
# print(has_nan)              Elapsed time    False
                              #  PCG              True
                              #  dtype: bool



# Assuming df_resampled is your DataFrame
mean_pcg = df_resampled['PCG'].mean()
df_resampled['PCG'].fillna(mean_pcg, inplace=True)


has_nan = df_resampled.isna().any()
print(has_nan)
print(df_resampled)

df_resampled.to_csv('Modified.csv')

t = pd.read_csv('Modified.csv')
dfr = t.loc[:, ['Elapsed time', 'PCG']].copy()
print(dfr)

sns.lineplot(x = dfr['Elapsed time'], y =dfr['PCG'])

#test, train = can split data

scaler = StandardScaler()
scaler = scaler.fit(dfr[['PCG']])
dfr.loc[:, 'PCG'] = scaler.transform(dfr[['PCG']])

scaler = scaler.fit(dfrt[['PCG']])
dfrt.loc[:, 'PCG'] = scaler.transform(dfrt[['PCG']])

n = 10
def sequence(x,y,n1):
  x_values = []
  y_values = []
  for i in range(len(x)-n1):
    x_values.append(x.iloc[i:(i+n1)])
    y_values.append(y.iloc[i+n1])
  return np.array(x_values), np.array(y_values)

trainX, trainY = sequence(dfr[['PCG']], dfr['PCG'], n)
testX, testY = sequence(dfrt[['PCG']], dfrt['PCG'], n)

print(trainX.shape)  #(72062, 10, 1)
print(trainY.shape)  #(72062,)

print(testX.shape)
print(testY.shape)

model = Sequential()
model.add(LSTM(128,input_shape=(trainX.shape[1],trainX.shape[2])))
model.add(Dropout(rate = 0.2))
model.add(RepeatVector(trainX.shape[1]))
model.add(LSTM(128,return_sequences=True))
model.add(Dropout(rate=0.2))
model.add(TimeDistributed(Dense(trainX.shape[2])))
model.compile(optimizer='adam',loss='mae')
model.summary()

h = model.fit(trainX,trainY,epochs=50,batch_size=32,validation_split =0.1)
plt.plot(h.history['loss'],label='Training loss')
plt.plot(h.history['val_loss'],label='validation loss')
plt.legend()

train_predict = model.predict(trainX)
train_MAE = np.mean(np.abs(train_predict-trainX),axis =1)
print(train_MAE.max())
plt.hist(train_MAE,bins=10)
max_train_MAE = 2.9

test_predict = model.predict(testX)
test_MAE = np.mean(np.abs(test_predict-testX),axis =1)
print(test_MAE.shape)
plt.hist(test_MAE,bins=10)

c=0
c1=0
for i in range(len(test_MAE)):
 if(test_MAE[i]>max_train_MAE):
   c+=1
print(c)
c1= test_MAE.shape[0]-c
print(c1)

if(c>c1):
  print("Anamoly")
else:
  print("Normal")

MAE_TEST = #Maximum mae from tested data.
if(MAE_TEST>MAE_MAX):
  print("ABNORMAL")
else:
  print("NORMAL")